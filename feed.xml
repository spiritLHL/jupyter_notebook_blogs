<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://spiritlhl.github.io/jupyter_notebook_blogs/feed.xml" rel="self" type="application/atom+xml" /><link href="https://spiritlhl.github.io/jupyter_notebook_blogs/" rel="alternate" type="text/html" /><updated>2021-01-21T08:35:11-06:00</updated><id>https://spiritlhl.github.io/jupyter_notebook_blogs/feed.xml</id><title type="html">SpiritLHL’s Python blog</title><subtitle>Personally explore Python's study notes.</subtitle><entry><title type="html">小额贷款的划算问题(matlab数学建模)</title><link href="https://spiritlhl.github.io/jupyter_notebook_blogs/2021/01/20/%E5%B0%8F%E9%A2%9D%E8%B4%B7%E6%AC%BE%E7%9A%84%E5%88%92%E7%AE%97%E9%97%AE%E9%A2%98(Matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1).html" rel="alternate" type="text/html" title="小额贷款的划算问题(matlab数学建模)" /><published>2021-01-20T00:00:00-06:00</published><updated>2021-01-20T00:00:00-06:00</updated><id>https://spiritlhl.github.io/jupyter_notebook_blogs/2021/01/20/%E5%B0%8F%E9%A2%9D%E8%B4%B7%E6%AC%BE%E7%9A%84%E5%88%92%E7%AE%97%E9%97%AE%E9%A2%98(Matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1)</id><author><name></name></author><summary type="html">学校要求的参赛论文，顺手发上博客了，有错漏欢迎在评论区留言。</summary></entry><entry><title type="html">Python新线程使用</title><link href="https://spiritlhl.github.io/jupyter_notebook_blogs/markdown/2020/08/31/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B(%E9%80%9A%E7%94%A8).html" rel="alternate" type="text/html" title="Python新线程使用" /><published>2020-08-31T00:00:00-05:00</published><updated>2020-08-31T00:00:00-05:00</updated><id>https://spiritlhl.github.io/jupyter_notebook_blogs/markdown/2020/08/31/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B(%E9%80%9A%E7%94%A8)</id><author><name></name></author><category term="markdown" /><summary type="html">创建并使用多线程 print('主线程执行代码') # 从 threading 库中导入Thread类 from threading import Thread from time import sleep # 定义一个函数，作为新线程执行的入口函数 def threadFunc(arg1,arg2): print('子线程 开始') print(f'线程函数参数是：{arg1}, {arg2}') sleep(5) print('子线程 结束') # 创建 Thread 类的实例对象， 并且指定新线程的入口函数，此时并没有执行 thread = Thread(target=threadFunc, args=('参数1', '参数2') ) #target=threadFunc对应执行的函数threadFunc #args=('参数1', '参数2')这样新进程添加参数 # 执行start 方法，就会创建新线程， # 并且新线程会去执行入口函数里面的代码。 # 这时候这个进程有两个线程了。↓ thread.start() # 主线程的代码执行 子线程对象的join方法， # 就会等待子线程结束，才继续执行下面的代码 thread.join() print('主线程结束') 运行该程序，解释器执行到下面代码时 thread = Thread(target=threadFunc, args=('参数1', '参数2') ) 创建了一个Thread实例对象，其中，Thread类的初始化参数 有两个 target参数 是指定新线程的 入口函数， 新线程创建后就会 执行该入口函数里面的代码， args 指定了 传给 入口函数threadFunc 的参数。 线程入口函数 参数，必须放在一个元组里面，里面的元素依次作为入口函数的参数。 注意，上面的代码只是创建了一个Thread实例对象， 但这时，新的线程还没有创建。 要创建线程，必须要调用 Thread 实例对象的 start方法 。也就是执行完下面代码的时候 thread.start() 新的线程才创建成功，并开始执行 入口函数threadFunc 里面的代码。 有的时候， 一个线程需要等待其它的线程结束，比如需要根据其他线程运行结束后的结果进行处理。 这时可以使用 Thread对象的 join 方法 thread.join() 如果一个线程A的代码调用了 对应线程B的Thread对象的 join 方法，线程A就会停止继续执行代码，等待线程B结束。 线程B结束后，线程A才继续执行后续的代码。 所以主线程在执行上面的代码时，就暂停在此处， 一直要等到 新线程执行完毕，退出后，才会继续执行后续的代码。 ```python #错误示例！！！！ thread = Thread(target=threadFunc('参数1', '参数2')) ↑如果这样写无法创建新线程并执行，这样target传入不是函数，传入的是运行结果(null)，而且是在主线程运行完了，并不是在子线程里运行。 共享数据的访问控制 做多线程开发，经常遇到这样的情况：多个线程里面的代码需要访问同一个公共的数据对象。 这个公共的数据对象可以是任何类型， 比如一个列表、字典、或者自定义类的对象。 有的时候，程序需要防止线程的代码同时操作公共数据对象。否则，就有可能导致数据的访问互相冲突影响。 请看一个例子。 我们用一个简单的程序模拟一个银行系统，用户可以往自己的帐号上存钱。 对应代码如下： from threading import Thread from time import sleep bank = { 'byhy' : 0 } # 定义一个函数，作为新线程执行的入口函数 def deposit(theadidx,amount): balance = bank['byhy'] # 执行一些任务，耗费了0.1秒 sleep(0.1) bank['byhy'] = balance + amount print(f'子线程 {theadidx} 结束') theadlist = [] for idx in range(10): thread = Thread(target = deposit, args = (idx,1) ) thread.start() # 把线程对象都存储到 threadlist中 theadlist.append(thread) for thread in theadlist: thread.join() print('主线程结束') print(f'最后我们的账号余额为 {bank[&quot;byhy&quot;]}') 上面的代码中，一起执行 开始的时候， 该帐号的余额为0，随后我们启动了10个线程， 每个线程都deposit函数，往帐号byhy上存1元钱。 可以预期，执行完程序后，该帐号的余额应该为 10。 然而，我们运行程序后，发现结果如下 子线程 0 结束 子线程 3 结束 子线程 2 结束 子线程 4 结束 子线程 1 结束 子线程 7 结束 子线程 5 结束 子线程 9 结束 子线程 6 结束 子线程 8 结束 主线程结束 最后我们的账号余额为 1 为什么是 1 呢？ 而不是 10 呢？ 如果在我们程序代码中，只有一个线程，如下所示 from time import sleep bank = { 'byhy' : 0 } # 定义一个函数，作为新线程执行的入口函数 def deposit(theadidx,amount): balance = bank['byhy'] # 执行一些任务，耗费了0.1秒 sleep(0.1) bank['byhy'] = balance + amount for idx in range(10): deposit (idx,1) print(f'最后我们的账号余额为 {bank[&quot;byhy&quot;]}') 代码都是串行执行的。不存在多线程同时访问bank对象的问题，运行结果一切都是正常的。 现在我们程序代码中，有多个线程，并且在这个几个线程中都会去调用deposit，就有可能同时操作这个bank对象，就有可能出一个线程覆盖另外一个线程的结果的问题。 这时，可以使用threading库里面的锁对象Lock去保护。 我们修改多线程代码，如下： from threading import Thread,Lock from time import sleep bank = { 'byhy' : 0 } bankLock = Lock() # 定义一个函数，作为新线程执行的入口函数 def deposit(theadidx,amount): # 操作共享数据前，申请获取锁 bankLock.acquire() balance = bank['byhy'] # 执行一些任务，耗费了0.1秒 sleep(0.1) bank['byhy'] = balance + amount print(f'子线程 {theadidx} 结束') # 操作完共享数据后，申请释放锁 bankLock.release() theadlist = [] for idx in range(10): thread = Thread(target = deposit, args = (idx,1) ) thread.start() # 把线程对象都存储到 threadlist中 theadlist.append(thread) for thread in theadlist: thread.join() print('主线程结束') print(f'最后我们的账号余额为 {bank[&quot;byhy&quot;]}') 执行一下，结果如下 子线程 0 结束 子线程 1 结束 子线程 2 结束 子线程 3 结束 子线程 4 结束 子线程 5 结束 子线程 6 结束 子线程 7 结束 子线程 8 结束 子线程 9 结束 主线程结束 最后我们的账号余额为 10 正确了。 每个线程在操作共享数据对象之前，都应该申请获取操作权，也就是调用该共享数据对象对应的锁对象的acquire方法。 如果线程A执行如下代码，调用acquire方法的时候， ```python bankLock.acquire() 别的线程B已经申请到了这个锁，并且还没有释放，那么线程A的代码就在此处等待线程B释放锁，不去执行后面的代码。 直到线程B执行了锁的release方法释放了这个锁，线程A才可以获取这个锁，就可以执行下面的代码了。 如果这时线程B又执行这个锁的acquire方法，就需要等待线程A执行该锁对象的release方法释放锁，否则也会等待，不去执行后面的代码。 daemon线程 from threading import Thread from time import sleep def threadFunc(): sleep(2) print('子线程 结束') thread = Thread(target=threadFunc) thread.start() print('主线程结束') 可以发现，主线程先结束，要过个2秒钟，等子线程运行完，整个程序才会结束退出。 因为： Python程序中当所有的 非daemon线程 结束了，整个程序才会结束 主线程是非daemon线程，启动的子线程缺省也是非daemon线程线程。 所以，要等到主线程和子线程都结束，程序才会结束。 我们可以在创建线程的时候，设置daemon参数值为True，如下 from threading import Thread from time import sleep def threadFunc(): sleep(2) print('子线程 结束') thread = Thread(target=threadFunc, daemon=True # 设置新线程为daemon线程 ) thread.start() print('主线程结束') 再次运行，可以发现，只要主线程结束了，整个程序就结束了。因为只有主线程是非daemon线程。</summary></entry><entry><title type="html">Matlab02(矩阵运算)</title><link href="https://spiritlhl.github.io/jupyter_notebook_blogs/markdown/2020/07/02/Matlab02.html" rel="alternate" type="text/html" title="Matlab02(矩阵运算)" /><published>2020-07-02T00:00:00-05:00</published><updated>2020-07-02T00:00:00-05:00</updated><id>https://spiritlhl.github.io/jupyter_notebook_blogs/markdown/2020/07/02/Matlab02</id><author><name></name></author><category term="markdown" /><summary type="html">通过下标引用矩阵元素 A(3,2)表示A矩阵第3行第2列的元素。 如若超出限制行列维数，自动扩展，未赋值的默认为0 通过序号来引用矩阵元素 A(3)等同于A(1,2) A(i,j)的序号为(j-1)×m+i ps:A(:)可以将矩阵A的每一列元素堆叠起来，成为一个列向量。 运算 数值运算是矩阵运算的特殊形式 .点运算是矩阵各个元素对应作运算 判断运算： == 等于 ~= 不等于 当参与比较的量是两个同型的矩阵时，比较是对两矩阵相同位置的元素按标量关系运算规则逐个进行，最终的关系运算的结果是一个与原矩阵同型的矩阵，它的元素由0或1组成。 当参与比较的一个是标量，而另一个 是矩阵时，则把标量与矩阵的每一个元素按标量 关系运算规则逐个比较，最终的关系运算的结果是一个与原矩阵同型的矩阵，它的元素由0或1组成。 逻辑运算： 在算术运算、关系运算和逻辑运算中，算术运算的优先级最高，逻辑运算优先级最低，但逻辑非运算是单目运算，它的优先级比双目运算要高。 ps:双目运算是有两个数参与运算。单目运算是只有一个数参与运算。a&amp;amp;b是双目运算。~a是单目运算 若参与逻辑运算的是两个同型矩阵，那么将对矩阵相同位置上的元素按标量规则逐个进行运算，最终运算结果是一个与原矩阵同型的矩阵，其元素由1或0组成。 若参与逻辑运算的一个是标量，一个是矩阵，那么将在标量与矩阵中的每个元素之间按标量规则逐个进行运算，最终运算结果是一个与原矩阵同型的矩阵，其元素由1或0组成。 字符串的表示 字符串是用单引号括起来的字符序列 字符串占一行，可通过(:)索引，类似Python切片操作，但区间是前包后闭 若字符串包含单引号，用两个单引号表示一个单引号 实战： 字符串的执行 矩阵处理 1.通用的特殊矩阵 2.魔方矩阵 3.范德蒙矩阵 4.希尔伯特矩阵 5.伴随矩阵 6.帕斯卡矩阵 7.函数</summary></entry><entry><title type="html">Matlab01(基础命令及函数)</title><link href="https://spiritlhl.github.io/jupyter_notebook_blogs/markdown/2020/07/01/Matlab01.html" rel="alternate" type="text/html" title="Matlab01(基础命令及函数)" /><published>2020-07-01T00:00:00-05:00</published><updated>2020-07-01T00:00:00-05:00</updated><id>https://spiritlhl.github.io/jupyter_notebook_blogs/markdown/2020/07/01/Matlab01</id><author><name></name></author><category term="markdown" /><summary type="html">基础命令 1.打开文件夹 命令行窗口输入 cd 文件夹名 这里推荐先在文件管理器先创建后打开 2.赋值变量会在工作区显示 可在命令行窗口输入whos 或 who 可以查看变量属性和具体参数 3.清空数据 clear 4.设置文件搜索路径 5.数字类型转换 class()函数可得数字类型 class(数字) 整型转换 int8() #转换成有符号的8位整型 uint8() #转换成无符号的8位整型 浮点型转换 数值数据默认为双精度型，可使用 single函数：single(数字)转换成单精度型 double函数：double(数字)转换成双精度型 复型 a+bi或a+bj real函数：取复型实部数据 image函数：取复型虚部数据 format命令格式 format long %输出长格式 format %输出短格式 format rat %输出有理数格式 这个不影响数据存储，只是表达方式不同 ps:%是注释符号，按ctrl+R注释一行，ctrl+T取消一行注释 6.常见函数 三角函数及取整函数 实战及其他函数 rem(除数,被除数)函数取余数 isprime(n)函数判断n是否为素数，当n是素数时返回1，否则返回0 find()函数找寻数组中的序列号 7.预定义变量 简单矩阵的建立 1.直接输入法 A=[1,2,3;4,5,6;7,8,9] 2.小矩阵拼接成大矩阵 A=[1,2,3;4,5,6;7,8,9] B=[-1,-2,3;-4,5,-6;-7,-8,-9] C=[A,B;B,A] 效果图： 3.用实部矩阵和虚部矩阵构成复数矩阵 B=[1,2,3;4,5,6] C=[6,7,8;9,10,11] A=B+i*C 效果图： 冒号表达式 结构矩阵和单元矩阵</summary></entry><entry><title type="html">2019新型冠状病毒（COVID-19/2019-nCoV）疫情分析</title><link href="https://spiritlhl.github.io/jupyter_notebook_blogs/2020/07/01/Cov2019Analysis.html" rel="alternate" type="text/html" title="2019新型冠状病毒（COVID-19/2019-nCoV）疫情分析" /><published>2020-07-01T00:00:00-05:00</published><updated>2020-07-01T00:00:00-05:00</updated><id>https://spiritlhl.github.io/jupyter_notebook_blogs/2020/07/01/Cov2019Analysis</id><author><name></name></author><summary type="html"></summary></entry></feed>